require("reflect-metadata");
require("./inject");
const { EventEmitter } = require("events");
const { ipcRenderer } = require("electron");

class VoxerEventEmitter extends EventEmitter {};

// Init preloader and configuration
global.__VOXER_PRELOAD__ = true;

const { contextBridge } = require("electron");

window.addEventListener("DOMContentLoaded", () => {});

// Voxer framework initialization

const events = new VoxerEventEmitter();

ipcRenderer.on("voxer:renderer", (event, channel, ...args) => {
    events.emit(channel, ...args);
});

contextBridge.exposeInMainWorld("voxer", {
    events: {
        on: events.on.bind(events),
        once: events.once.bind(events),
        off: events.off.bind(events),
        send: ipcRenderer.send.bind(ipcRenderer),
        sendSync: ipcRenderer.sendSync.bind(ipcRenderer),
        invoke: ipcRenderer.invoke.bind(ipcRenderer),
    },
});

<% if (isTs) { %>
require("./dist/src/main").preload?.();
<% } else { %>
require("../src/main").preload?.();
<% } %>

<% if (isTs) {  %>
const { inject: getInjectables} = require("./dist/src/main.js");
<% } else { %>
const { inject: getInjectables } = require("../src/main.js");
<% } %>

if (getInjectables) {
    const injectables = getInjectables();

    for (const injectable of injectables) {
        const api = {};

        for (const method of injectable.__exposedMethods) {
            api[method] = (...args) => ipcRenderer.invoke(injectable.name + "." + method, ...args);
        }

        contextBridge.exposeInMainWorld(injectable.name, api);
    }
}